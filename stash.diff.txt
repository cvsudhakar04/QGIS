diff --git a/src/3d/qgs3dmapscene.h b/src/3d/qgs3dmapscene.h
index 09fa8e59f1..87557ad910 100644
--- a/src/3d/qgs3dmapscene.h
+++ b/src/3d/qgs3dmapscene.h
@@ -182,6 +182,7 @@ class _3D_EXPORT Qgs3DMapScene : public Qt3DCore::QEntity
     int maximumTextureSize() const;
 
   private:
+    // Needs automatic allocation management?
     const Qgs3DMapSettings &mMap;
     QgsAbstract3DEngine *mEngine = nullptr;
     //! Provides a way to have a synchronous function executed each frame
diff --git a/src/3d/qgs3dutils.cpp b/src/3d/qgs3dutils.cpp
index 506e188c9c..794563fc33 100644
--- a/src/3d/qgs3dutils.cpp
+++ b/src/3d/qgs3dutils.cpp
@@ -86,6 +86,51 @@ QImage Qgs3DUtils::captureSceneImage( QgsAbstract3DEngine &engine, Qgs3DMapScene
   return resImage;
 }
 
+QImage Qgs3DUtils::captureSceneDepthBuffer( QgsAbstract3DEngine &engine, Qgs3DMapScene *scene )
+{
+  QImage resImage;
+  QEventLoop evLoop;
+
+  // We need to change render policy to RenderPolicy::Always, since otherwise render capture node won't work
+  engine.renderSettings()->setRenderPolicy( Qt3DRender::QRenderSettings::RenderPolicy::Always );
+
+  auto requestImageFcn = [&engine, scene]
+  {
+    if ( scene->sceneState() == Qgs3DMapScene::Ready )
+    {
+      engine.requestCaptureImage();
+    }
+  };
+
+  auto saveImageFcn = [&evLoop, &resImage]( const QImage & img )
+  {
+    resImage = img;
+    evLoop.quit();
+  };
+
+  QMetaObject::Connection conn1 = QObject::connect( &engine, &QgsAbstract3DEngine::imageCaptured, saveImageFcn );
+  QMetaObject::Connection conn2;
+
+  if ( scene->sceneState() == Qgs3DMapScene::Ready )
+  {
+    requestImageFcn();
+  }
+  else
+  {
+    // first wait until scene is loaded
+    conn2 = QObject::connect( scene, &Qgs3DMapScene::sceneStateChanged, requestImageFcn );
+  }
+
+  evLoop.exec();
+
+  QObject::disconnect( conn1 );
+  if ( conn2 )
+    QObject::disconnect( conn2 );
+
+  engine.renderSettings()->setRenderPolicy( Qt3DRender::QRenderSettings::RenderPolicy::OnDemand );
+  return resImage;
+}
+
 bool Qgs3DUtils::exportAnimation( const Qgs3DAnimationSettings &animationSettings,
                                   const Qgs3DMapSettings &mapSettings,
                                   int framesPerSecond,
@@ -604,7 +649,7 @@ QVector3D Qgs3DUtils::mouseToWorldPos( const QVector3D &mousePos, const QRect &v
   QMatrix4x4 invPersMatrix = persMatrix.inverted();
   QVector3D ndcPos;
   ndcPos.setX( 2.0 * mousePos.x() / viewPort.width() - 1 );
-  ndcPos.setY( 2.0 * mousePos.y() / viewPort.height() - 1 );
+  ndcPos.setY( -2.0 * mousePos.y() / viewPort.height() + 1 );
   ndcPos.setZ( 2.0 * mousePos.z() - 1.0 );
 
   QVector4D clipPos;
diff --git a/src/3d/qgs3dutils.h b/src/3d/qgs3dutils.h
index a3e02a5d9e..e5abd15c3b 100644
--- a/src/3d/qgs3dutils.h
+++ b/src/3d/qgs3dutils.h
@@ -60,6 +60,14 @@ class _3D_EXPORT Qgs3DUtils
      */
     static QImage captureSceneImage( QgsAbstract3DEngine &engine, Qgs3DMapScene *scene );
 
+    /**
+     * Captures the depth buffer of the current 3D scene of a 3D engine. The function waits
+     * until the scene is not fully loaded/updated before capturing the image.
+     * \since QGIS 3.4
+     */
+    static QImage captureSceneDepthBuffer( QgsAbstract3DEngine &engine, Qgs3DMapScene *scene );
+
+
     /**
      * Captures 3D animation frames to the selected folder
      *
diff --git a/src/3d/qgsabstract3dengine.cpp b/src/3d/qgsabstract3dengine.cpp
index b50125a276..a62ec558e9 100644
--- a/src/3d/qgsabstract3dengine.cpp
+++ b/src/3d/qgsabstract3dengine.cpp
@@ -29,6 +29,7 @@ QgsAbstract3DEngine::QgsAbstract3DEngine( QObject *parent )
 void QgsAbstract3DEngine::requestCaptureImage()
 {
   Qt3DRender::QRenderCaptureReply *captureReply;
+  mTimer.start();
   captureReply = mFrameGraph->renderCapture()->requestCapture();
   // We need to change render policy to RenderPolicy::Always, since otherwise render capture node won't work
   this->renderSettings()->setRenderPolicy( Qt3DRender::QRenderSettings::RenderPolicy::Always );
@@ -40,6 +41,21 @@ void QgsAbstract3DEngine::requestCaptureImage()
   } );
 }
 
+void QgsAbstract3DEngine::requestDepthBufferCapture()
+{
+  Qt3DRender::QRenderCaptureReply *captureReply;
+  mTimer.start();
+  captureReply = mFrameGraph->depthRenderCapture()->requestCapture();
+  // We need to change render policy to RenderPolicy::Always, since otherwise render capture node won't work
+  this->renderSettings()->setRenderPolicy( Qt3DRender::QRenderSettings::RenderPolicy::Always );
+  connect( captureReply, &Qt3DRender::QRenderCaptureReply::completed, this, [ = ]
+  {
+    emit depthBufferCaptured( captureReply->image() );
+    this->renderSettings()->setRenderPolicy( Qt3DRender::QRenderSettings::RenderPolicy::OnDemand );
+    captureReply->deleteLater();
+  } );
+}
+
 void QgsAbstract3DEngine::setRenderCaptureEnabled( bool enabled )
 {
   mFrameGraph->setRenderCaptureEnabled( enabled );
diff --git a/src/3d/qgsabstract3dengine.h b/src/3d/qgsabstract3dengine.h
index 50c18db706..22acd60c24 100644
--- a/src/3d/qgsabstract3dengine.h
+++ b/src/3d/qgsabstract3dengine.h
@@ -19,6 +19,7 @@
 #include "qgis_3d.h"
 
 #include <QObject>
+#include <QElapsedTimer>
 
 #define SIP_NO_FILE
 
@@ -66,6 +67,8 @@ class _3D_EXPORT QgsAbstract3DEngine : public QObject
      */
     QgsAbstract3DEngine( QObject *parent = nullptr );
 
+    QElapsedTimer mTimer;
+
     //! Sets background color of the scene
     virtual void setClearColor( const QColor &color ) = 0;
     //! Sets whether frustum culling is enabled (this should make rendering faster by not rendering entities outside of camera's view)
@@ -89,6 +92,13 @@ class _3D_EXPORT QgsAbstract3DEngine : public QObject
      */
     void requestCaptureImage();
 
+    /**
+     * Starts a request for an image containing the depth buffer data of the engine.
+     * The function does not block - when the depth buffer image is captured, it is returned in depthBufferCaptured() signal.
+     * Only one image request can be active at a time.
+     */
+    void requestDepthBufferCapture();
+
     /**
      * Returns the surface of the engine
      *
@@ -121,8 +131,11 @@ class _3D_EXPORT QgsAbstract3DEngine : public QObject
     //! Emitted after a call to requestCaptureImage() to return the captured image.
     void imageCaptured( const QImage &image );
 
+    //! Emitted after a call to requestDepthBufferCapture() to return the captured depth buffer.
+    void depthBufferCaptured( const QImage &image );
+
   protected:
-    QgsShadowRenderingFrameGraph *mFrameGraph = nullptr;
+    QgsShadowRenderingFrameGraph *mFrameGraph = nullptr;\
 };
 
 
diff --git a/src/3d/qgscameracontroller.cpp b/src/3d/qgscameracontroller.cpp
index 8f47e6eaa3..318f75f7c8 100644
--- a/src/3d/qgscameracontroller.cpp
+++ b/src/3d/qgscameracontroller.cpp
@@ -276,7 +276,7 @@ void QgsCameraController::readXml( const QDomElement &elem )
   setLookingAtPoint( QgsVector3D( x, elev, y ), dist, pitch, yaw );
 }
 
-void QgsCameraController::updateCameraFromPose( bool centerPointChanged )
+void QgsCameraController::updateCameraFromPose( bool centerPointChanged, bool emitSignal )
 {
   if ( std::isnan( mCameraPose.centerPoint().x() ) || std::isnan( mCameraPose.centerPoint().y() ) || std::isnan( mCameraPose.centerPoint().z() ) )
   {
@@ -302,9 +302,29 @@ void QgsCameraController::updateCameraFromPose( bool centerPointChanged )
     // figure out our distance from terrain and update the camera's view center
     // so that camera tilting and rotation is around a point on terrain, not an point at fixed elevation
     QVector3D intersectionPoint;
-    QgsRayCastingUtils::Ray3D ray = QgsRayCastingUtils::rayForCameraCenter( mCamera );
+    QVector3D rayDirection;
+
+    auto calculateAngles = [&]( QVector3D dir ) -> QPair<double, double>
+    {
+      double calculatedPitch = qRadiansToDegrees( acos(dir.y()) );
+      double calculatedYaw = 90 - qRadiansToDegrees( atan2( dir.z(), dir.x() ) );
+      return QPair<double, double>( calculatedPitch, calculatedYaw );
+    };
+
+    {
+      Qt3DRender::QCamera camera;
+      camera.setUpVector( QVector3D( 0, 0, -1 ) );
+      camera.setPosition( QVector3D( mCameraPose.centerPoint().x(), mCameraPose.distanceFromCenterPoint() + mCameraPose.centerPoint().y(), mCameraPose.centerPoint().z() ) );
+      camera.setViewCenter( QVector3D( mCameraPose.centerPoint().x(), mCameraPose.centerPoint().y(), mCameraPose.centerPoint().z() ) );
+      camera.rotateAboutViewCenter( QQuaternion::fromEulerAngles( mCameraPose.pitchAngle(), mCameraPose.headingAngle(), 0 ) );
+      rayDirection = (camera.viewCenter() - camera.position()).normalized();
+    }
+//    QQuaternion::rotationTo(  )
+//    QgsRayCastingUtils::Ray3D ray = QgsRayCastingUtils::rayForCameraCenter( mCamera );
+    QgsRayCastingUtils::Ray3D ray( mCamera->position(), rayDirection, 1000000 );
     if ( mTerrainEntity->rayIntersection( ray, intersectionPoint ) )
     {
+      qDebug() << "INTERSECTED";
       float dist = ( intersectionPoint - mCamera->position() ).length();
       mCameraPose.setDistanceFromCenterPoint( dist );
       mCameraPose.setCenterPoint( QgsVector3D( intersectionPoint ) );
@@ -312,27 +332,29 @@ void QgsCameraController::updateCameraFromPose( bool centerPointChanged )
     }
     else
     {
-      QgsVector3D centerPoint = mCameraPose.centerPoint();
-      double d = ( elevation - ray.origin().y() ) / ray.direction().y();
-      centerPoint = ray.origin() + d * ray.direction();
-//      centerPoint.set( centerPoint.x(), mTerrainEntity->terrainElevationOffset(), centerPoint.z() );
-      mCameraPose.setCenterPoint( centerPoint );
-      mCameraPose.updateCamera( mCamera );
+//      QgsVector3D centerPoint = mCameraPose.centerPoint();
+////      QgsRay3D ray( mCamera->position(), (centerPoint.toVector3D() - mCamera->position()).normalized() );
+//      double d = ( elevation - ray.origin().y() ) / ray.direction().y();
+//      centerPoint = ray.origin() + d * ray.direction();
+////      centerPoint.set( centerPoint.x(), mTerrainEntity->terrainElevationOffset(), centerPoint.z() );
+//      mCameraPose.setCenterPoint( centerPoint );
+//      mCameraPose.updateCamera( mCamera );
     }
   }
 
-  if ( mCamera && !mTerrainEntity && centerPointChanged )
-  {
-    QgsVector3D centerPoint = mCameraPose.centerPoint();
-    QVector3D ray_direction = ( centerPoint.toVector3D() - mCamera->position() ).normalized();
-    double d = ( elevation - mCamera->position().y() ) / ray_direction.y();
-    centerPoint = mCamera->position() + d * ray_direction;
-//    centerPoint.set( centerPoint.x(), 0, centerPoint.z() );
-    mCameraPose.setCenterPoint( centerPoint );
-    mCameraPose.updateCamera( mCamera );
-  }
-
-  emit cameraChanged();
+//  if ( mCamera && !mTerrainEntity && centerPointChanged )
+//  {
+//    QgsVector3D centerPoint = mCameraPose.centerPoint();
+//    QVector3D ray_direction = ( centerPoint.toVector3D() - mCamera->position() ).normalized();
+//    double d = ( elevation - mCamera->position().y() ) / ray_direction.y();
+//    centerPoint = mCamera->position() + d * ray_direction;
+////    centerPoint.set( centerPoint.x(), 0, centerPoint.z() );
+//    mCameraPose.setCenterPoint( centerPoint );
+//    mCameraPose.updateCamera( mCamera );
+//  }
+
+  if ( emitSignal )
+    emit cameraChanged();
 }
 
 double QgsCameraController::cameraCenterElevation( bool centerPointChanged )
@@ -424,21 +446,34 @@ void QgsCameraController::onPositionChangedTerrainNavigation( Qt3DInput::QMouseE
     pitch += 0.2f * dy;
     yaw -= 0.2f * dx;
 
-    QVector3D lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint( mMousePos.x(), mMousePos.y(), mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
-    mCameraPose.setCenterPoint( lookAtPos );
-
     mCameraPose.setPitchAngle( pitch );
     mCameraPose.setHeadingAngle( yaw );
+    updateCameraFromPose();
 
-    updateCameraFromPose( true );
+    qDebug() << "pitch: " << pitch << ", yaw: " << yaw;
 
-    lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint(
-                  ( -double( mMousePos.x() ) / mViewport.width() + 1.0 ) * mViewport.width(),
-                  ( -double( mMousePos.y() ) / mViewport.height() + 1.0 ) * mViewport.height(),
-                  mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
-    mCameraPose.setCenterPoint( lookAtPos );
+    // Find pitch and yaw from camera
+    QVector3D dir = -mCamera->viewVector().normalized();
+    double calculatedPitch = qRadiansToDegrees( acos(dir.y()) );
+    double calculatedYaw = 90 - qRadiansToDegrees( atan2( dir.z(), dir.x() ) );
+    qDebug() << "calculatedPitch: " << calculatedPitch << ", calculatedYaw: " << calculatedYaw;
 
-    updateCameraFromPose( true );
+
+//    QVector3D lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint( mMousePos.x(), mMousePos.y(), mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
+//    mCameraPose.setCenterPoint( lookAtPos );
+
+//    mCameraPose.setPitchAngle( pitch );
+//    mCameraPose.setHeadingAngle( yaw );
+
+//    updateCameraFromPose( true );
+
+//    lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint(
+//                  ( -double( mMousePos.x() ) / mViewport.width() + 1.0 ) * mViewport.width(),
+//                  ( -double( mMousePos.y() ) / mViewport.height() + 1.0 ) * mViewport.height(),
+//                  mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
+//    mCameraPose.setCenterPoint( lookAtPos );
+
+//    updateCameraFromPose( true );
   }
   else if ( hasLeftButton && hasCtrl && !hasShift )
   {
@@ -484,6 +519,10 @@ void QgsCameraController::zoom( float factor )
 
 void QgsCameraController::onWheel( Qt3DInput::QWheelEvent *wheel )
 {
+  bool locked = mMutex.try_lock();
+  if ( !locked )
+    return;
+
   switch ( mCameraNavigationMode )
   {
     case QgsCameraController::WalkNavigation:
@@ -495,26 +534,100 @@ void QgsCameraController::onWheel( Qt3DInput::QWheelEvent *wheel )
 
     case TerrainBasedNavigation:
     {
+      QVector3D originalViewCenter = camera()->viewCenter();
+
       float scaling = ( ( wheel->modifiers() & Qt::ControlModifier ) ? 0.1f : 1.0f ) / 1000.f;
       float dist = mCameraPose.distanceFromCenterPoint();
       dist -= dist * scaling * wheel->angleDelta().y();
 
-      QVector3D lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint( mMousePos.x(), mMousePos.y(), mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
-      mCameraPose.setCenterPoint( lookAtPos );
-      mCameraPose.setDistanceFromCenterPoint( dist );
-      updateCameraFromPose( true );
+      mDepthBufferImage = QImage();
+      emit requestDepthBufferCapture();
+      QEventLoop loop;
+      QTimer timer;
+      connect(&timer, SIGNAL(timeout()), &loop, SLOT(quit()));
+      timer.start(100);
+      loop.exec();
+
+      qDebug() << "\n\n";
+      qDebug() << "BEFORE:";
+      qDebug() << "pitch: " << mCameraPose.pitchAngle();
+      qDebug() << "yaw: " << mCameraPose.headingAngle();
+      qDebug() << "center point: " << mCameraPose.centerPoint().toVector3D();
+
+      qDebug() << "Depth image size: " << mDepthBufferImage.size();
+      qDebug() << "MousePos: " << mMousePos;
+      qDebug() << "mDepthBufferImage BBP: " << mDepthBufferImage.depth();
+
+      QRgb pixel = mDepthBufferImage.pixel( mMousePos.x(), mMousePos.y() );
+      double depth = qRed( pixel ) * 256.0 * 256.0 + qGreen( pixel ) * 256.0 + qBlue( pixel );
+      depth /= 256.0 * 256.0 * 256;
+
+      qDebug() << "depth: " << depth;
+
+      QVector2D texCoord = QVector2D( 2.0 * mMousePos.x() / mViewport.width() - 1.0, -2.0 * mMousePos.y() / mViewport.height() + 1.0 );
+
+      auto WorldPosFromDepth = []( QVector2D texCoord, float depth, Qt3DRender::QCamera *camera ) {
+          float z = depth * 2.0 - 1.0;
+          QVector4D clipSpacePosition = QVector4D(texCoord.x(), texCoord.y(), z, 1.0);
+          QVector4D viewSpacePosition = camera->projectionMatrix().inverted() * clipSpacePosition;
 
-      lookAtPos = Qgs3DUtils::mouseToWorldLookAtPoint(
-                    ( -double( mMousePos.x() ) / mViewport.width() + 1.0 ) * mViewport.width(),
-                    ( -double( mMousePos.y() ) / mViewport.height() + 1.0 ) * mViewport.height(),
-                    mCameraPose.distanceFromCenterPoint(), mViewport, mCamera );
+          // Perspective division
+          viewSpacePosition /= viewSpacePosition.w();
 
+          QVector4D worldSpacePosition = camera->viewMatrix().inverted() * viewSpacePosition;
+
+          return QVector3D( worldSpacePosition.x(), worldSpacePosition.y(), worldSpacePosition.z() );
+      };
+
+      auto calculateAngles = [&]( QVector3D dir ) -> QPair<double, double>
+      {
+        double calculatedPitch = qRadiansToDegrees( acos(dir.y()) );
+        double calculatedYaw = 90 - qRadiansToDegrees( atan2( dir.z(), dir.x() ) );
+        return QPair<double, double>( calculatedPitch, calculatedYaw );
+      };
+
+      QVector3D lookAtPos = WorldPosFromDepth( texCoord, depth, camera() );
+//      lookAtPos = mCamera->position() + mCameraPose.distanceFromCenterPoint() * (lookAtPos - mCamera->position()).normalized();
+      mCamera->setPosition( mCameraPose.centerPoint().toVector3D() - dist * mCamera->viewVector().normalized() );
+      qDebug() << "texCoord: " << texCoord << " " << depth;
+      QVector4D pos = camera()->projectionMatrix() * mCamera->viewMatrix() * QVector4D( lookAtPos, 1.0 );
+      pos /= pos.w();
+      qDebug() << "texCoords after: " << pos;
+
+      mCameraPose.setDistanceFromCenterPoint( dist );
       mCameraPose.setCenterPoint( lookAtPos );
+      mCameraPose.updateCamera( mCamera );
 
+//      updateCameraFromPose( true, false );
+
+
+//      updateCameraFromPose( true, false );
+
+      QVector3D fromPos = lookAtPos;//WorldPosFromDepth( QVector2D( 0, 0 ), 0, camera() );
+      QVector3D toPos = WorldPosFromDepth( -QVector2D( texCoord.x(), texCoord.y() ), 0, camera() );
+
+      qDebug() << "Option1: " << WorldPosFromDepth( -QVector2D( texCoord.x(), texCoord.y() ), 0, camera() );
+      qDebug() << "Option2: " << WorldPosFromDepth( -QVector2D( pos.x(), pos.y() ), 0, camera() );
+
+      qDebug() << "lookAtPos: " << lookAtPos;
+      qDebug() << "toPos: " << toPos;
+
+      QVector3D from = (fromPos - mCamera->position()).normalized();
+      QVector3D to = (toPos - mCamera->position()).normalized();
+
+      QQuaternion rot = QQuaternion::rotationTo( from, to );
+      camera()->rotate( rot );
+      QVector3D newCenterPoint = mCamera->viewCenter();
+//      QVector3D newCenterPoint = mCamera->position() + mCameraPose.distanceFromCenterPoint() * (rot * mCamera->viewVector()).normalized();
+      camera()->rotate( rot.conjugated() );
+
+      mCameraPose.setCenterPoint( newCenterPoint );
+      mCameraPose.updateCamera( mCamera );
       updateCameraFromPose( true );
       break;
     }
   }
+  mMutex.unlock();
 }
 
 void QgsCameraController::onMousePressed( Qt3DInput::QMouseEvent *mouse )
@@ -926,3 +1039,8 @@ bool QgsCameraController::willHandleKeyEvent( QKeyEvent *event )
   }
   return false;
 }
+
+void QgsCameraController::setDepthBufferImage( const QImage &depthImage )
+{
+  mDepthBufferImage = depthImage;
+}
diff --git a/src/3d/qgscameracontroller.h b/src/3d/qgscameracontroller.h
index e7dbec1c49..987d3e48d5 100644
--- a/src/3d/qgscameracontroller.h
+++ b/src/3d/qgscameracontroller.h
@@ -22,6 +22,8 @@
 #include <QRect>
 #include <Qt3DCore/QEntity>
 #include <Qt3DInput/QMouseEvent>
+#include <QImage>
+#include <QMutex>
 
 namespace Qt3DInput
 {
@@ -206,6 +208,7 @@ class _3D_EXPORT QgsCameraController : public Qt3DCore::QEntity
      */
     bool willHandleKeyEvent( QKeyEvent *event );
 
+    void setDepthBufferImage( const QImage &depthImage );
   public slots:
 
     /**
@@ -216,7 +219,7 @@ class _3D_EXPORT QgsCameraController : public Qt3DCore::QEntity
 
   private:
     void rotateCamera( float diffPitch, float diffYaw );
-    void updateCameraFromPose( bool centerPointChanged = false );
+    void updateCameraFromPose( bool centerPointChanged = false, bool emitSignal = true );
     void moveCameraPositionBy( const QVector3D &posDiff );
 
   signals:
@@ -238,6 +241,8 @@ class _3D_EXPORT QgsCameraController : public Qt3DCore::QEntity
      */
     void setCursorPosition( QPoint point );
 
+    void requestDepthBufferCapture();
+
   private slots:
     void onPositionChanged( Qt3DInput::QMouseEvent *mouse );
     void onWheel( Qt3DInput::QWheelEvent *wheel );
@@ -288,6 +293,9 @@ class _3D_EXPORT QgsCameraController : public Qt3DCore::QEntity
     QTimer *mFpsNavTimer = nullptr;
 
     double cameraCenterElevation( bool centerPointChanged );
+
+    QImage mDepthBufferImage;
+    QMutex mMutex;
 };
 
 #endif // QGSCAMERACONTROLLER_H
diff --git a/src/3d/qgscamerapose.cpp b/src/3d/qgscamerapose.cpp
index b7a949166a..0f1ac379ed 100644
--- a/src/3d/qgscamerapose.cpp
+++ b/src/3d/qgscamerapose.cpp
@@ -18,6 +18,8 @@
 #include <Qt3DRender/QCamera>
 
 #include <QDomDocument>
+#include <QVector2D>
+#include <QtMath>
 
 QDomElement QgsCameraPose::writeXml( QDomDocument &doc ) const
 {
@@ -55,3 +57,15 @@ void QgsCameraPose::updateCamera( Qt3DRender::QCamera *camera )
   camera->setViewCenter( QVector3D( mCenterPoint.x(), mCenterPoint.y(), mCenterPoint.z() ) );
   camera->rotateAboutViewCenter( QQuaternion::fromEulerAngles( mPitchAngle, mHeadingAngle, 0 ) );
 }
+
+void QgsCameraPose::setupFromCamera( Qt3DRender::QCamera *camera )
+{
+//  QQuaternion rot = QQuaternion::rotationTo( QVector3D( 0, 0, -1 ), camera->upVector() );
+//  QVector3D eulerAngles = rot.toEulerAngles();
+//  qDebug() << __PRETTY_FUNCTION__ << ":" << eulerAngles;
+
+//  mCenterPoint = QgsVector3D( camera->viewCenter() );
+//  mDistanceFromCenterPoint = (camera->viewCenter() - camera->position()).length();
+//  mPitchAngle = eulerAngles.x();
+//  mHeadingAngle = eulerAngles.y();
+}
diff --git a/src/3d/qgscamerapose.h b/src/3d/qgscamerapose.h
index e7caa80f71..8a85f0ad22 100644
--- a/src/3d/qgscamerapose.h
+++ b/src/3d/qgscamerapose.h
@@ -70,6 +70,9 @@ class _3D_EXPORT QgsCameraPose
     //! Update Qt3D camera view matrix based on the pose
     void updateCamera( Qt3DRender::QCamera *camera ) SIP_SKIP;
 
+    //! Sets the QgsCameraPose data form \a camera configuration
+    void setupFromCamera( Qt3DRender::QCamera *camera ) SIP_SKIP;
+
     //! Writes configuration to a new DOM element and returns it
     QDomElement writeXml( QDomDocument &doc ) const;
     //! Reads configuration from a DOM element previously written using writeXml()
diff --git a/src/3d/qgsshadowrenderingframegraph.cpp b/src/3d/qgsshadowrenderingframegraph.cpp
index d02fed121e..f69fef7699 100644
--- a/src/3d/qgsshadowrenderingframegraph.cpp
+++ b/src/3d/qgsshadowrenderingframegraph.cpp
@@ -55,7 +55,7 @@ Qt3DRender::QFrameGraphNode *QgsShadowRenderingFrameGraph::constructForwardRende
   mForwardDepthTexture = new Qt3DRender::QTexture2D;
   mForwardDepthTexture->setWidth( mSize.width() );
   mForwardDepthTexture->setHeight( mSize.height() );
-  mForwardDepthTexture->setFormat( Qt3DRender::QTexture2D::TextureFormat::DepthFormat );
+  mForwardDepthTexture->setFormat( Qt3DRender::QTexture2D::TextureFormat::D32F );
   mForwardDepthTexture->setGenerateMipMaps( false );
   mForwardDepthTexture->setMagnificationFilter( Qt3DRender::QTexture2D::Linear );
   mForwardDepthTexture->setMinificationFilter( Qt3DRender::QTexture2D::Linear );
@@ -76,8 +76,9 @@ Qt3DRender::QFrameGraphNode *QgsShadowRenderingFrameGraph::constructForwardRende
   mForwardRenderTargetSelector->setTarget( mForwardRenderTarget );
 
   mForwardClearBuffers = new Qt3DRender::QClearBuffers( mForwardRenderTargetSelector );
-  mForwardClearBuffers->setClearColor( QColor::fromRgbF( 0.0, 1.0, 0.0, 1.0 ) );
+  mForwardClearBuffers->setClearColor( QColor::fromRgbF( 0.0, 0.0, 1.0, 1.0 ) );
   mForwardClearBuffers->setBuffers( Qt3DRender::QClearBuffers::ColorDepthBuffer );
+  mForwardClearBuffers->setClearDepthValue( 1.0f );
 
   mFrustumCulling = new Qt3DRender::QFrustumCulling( mForwardClearBuffers );
 
@@ -109,7 +110,9 @@ Qt3DRender::QFrameGraphNode *QgsShadowRenderingFrameGraph::constructShadowRender
   mShadowRenderTargetSelector->setTarget( mShadowRenderTarget );
 
   mShadowClearBuffers = new Qt3DRender::QClearBuffers( mShadowRenderTargetSelector );
-  mShadowClearBuffers ->setBuffers( Qt3DRender::QClearBuffers::BufferType::ColorDepthBuffer );
+  mShadowClearBuffers->setBuffers( Qt3DRender::QClearBuffers::BufferType::ColorDepthBuffer );
+  mShadowClearBuffers->setClearColor( QColor::fromRgbF( 0.0f, 1.0f, 0.0f ) );
+
 
   mShadowRenderStateSet = new Qt3DRender::QRenderStateSet( mShadowClearBuffers );
   mShadowDepthTest = new Qt3DRender::QDepthTest;
@@ -128,7 +131,6 @@ Qt3DRender::QFrameGraphNode *QgsShadowRenderingFrameGraph::constructPostprocessi
   mPostprocessPassLayerFilter->addLayer( mPostprocessPassLayer );
 
   mPostprocessClearBuffers = new Qt3DRender::QClearBuffers( mPostprocessPassLayerFilter );
-  mPostprocessClearBuffers->setClearColor( QColor::fromRgbF( 0.0f, 0.0f, 0.0f ) );
 
   mRenderCaptureTargetSelector = new Qt3DRender::QRenderTargetSelector( mPostprocessPassLayerFilter );
 
@@ -144,7 +146,7 @@ Qt3DRender::QFrameGraphNode *QgsShadowRenderingFrameGraph::constructPostprocessi
   // Create a texture to render into.
   mRenderCaptureColorTexture = new Qt3DRender::QTexture2D( colorOutput );
   mRenderCaptureColorTexture->setSize( mSize.width(), mSize.height() );
-  mRenderCaptureColorTexture->setFormat( Qt3DRender::QAbstractTexture::RGB8_UNorm );
+  mRenderCaptureColorTexture->setFormat( Qt3DRender::QAbstractTexture::RGBA8_UNorm );
   mRenderCaptureColorTexture->setMinificationFilter( Qt3DRender::QAbstractTexture::Linear );
   mRenderCaptureColorTexture->setMagnificationFilter( Qt3DRender::QAbstractTexture::Linear );
 
@@ -185,11 +187,13 @@ QgsShadowRenderingFrameGraph::QgsShadowRenderingFrameGraph( QSurface *surface, Q
   mPreviewLayer = new Qt3DRender::QLayer;
   mCastShadowsLayer = new Qt3DRender::QLayer;
   mForwardRenderLayer = new Qt3DRender::QLayer;
+  mDepthRenderPassLayer = new Qt3DRender::QLayer;
 
   mPostprocessPassLayer->setRecursive( true );
   mPreviewLayer->setRecursive( true );
   mCastShadowsLayer->setRecursive( true );
   mForwardRenderLayer->setRecursive( true );
+  mDepthRenderPassLayer->setRecursive( true );
 
   mRenderSurfaceSelector = new Qt3DRender::QRenderSurfaceSelector;
 
@@ -220,18 +224,84 @@ QgsShadowRenderingFrameGraph::QgsShadowRenderingFrameGraph( QSurface *surface, Q
   Qt3DRender::QFrameGraphNode *postprocessingPass = constructPostprocessingPass();
   postprocessingPass->setParent( mLightCameraSelector );
 
+  mSecondMainCameraSelector = new Qt3DRender::QCameraSelector( mLightCameraSelector );
+  mSecondMainCameraSelector->setCamera( mMainCamera );
+
+  DepthRenderStateSet = new Qt3DRender::QRenderStateSet( mSecondMainCameraSelector );
+  auto *DepthRenderDepthTest = new Qt3DRender::QDepthTest;
+  DepthRenderDepthTest->setDepthFunction( Qt3DRender::QDepthTest::Always );
+  DepthRenderStateSet->addRenderState( DepthRenderDepthTest );
+  auto *DepthRenderCullFace = new Qt3DRender::QCullFace;
+  DepthRenderCullFace->setMode( Qt3DRender::QCullFace::NoCulling );
+  DepthRenderStateSet->addRenderState( DepthRenderCullFace );
+
+  mDepthRenderLayerFilter = new Qt3DRender::QLayerFilter( DepthRenderStateSet );
+  mDepthRenderLayerFilter->addLayer( mDepthRenderPassLayer );
+
+  mDepthRenderCaptureTargetSelector = new Qt3DRender::QRenderTargetSelector( mDepthRenderLayerFilter );
+  Qt3DRender::QRenderTarget *depthRenderTarget = new Qt3DRender::QRenderTarget( mDepthRenderCaptureTargetSelector );
+
+  // The lifetime of the objects created here is managed
+  // automatically, as they become children of this object.
+
+  // Create a render target output for rendering color.
+  Qt3DRender::QRenderTargetOutput *colorOutput = new Qt3DRender::QRenderTargetOutput( depthRenderTarget );
+  colorOutput->setAttachmentPoint( Qt3DRender::QRenderTargetOutput::Color0 );
+
+  // Create a texture to render into.
+  mDepthRenderCaptureColorTexture = new Qt3DRender::QTexture2D( colorOutput );
+  mDepthRenderCaptureColorTexture->setSize( mSize.width(), mSize.height() );
+  mDepthRenderCaptureColorTexture->setFormat( Qt3DRender::QAbstractTexture::RGBA8_UNorm );
+  mDepthRenderCaptureColorTexture->setMinificationFilter( Qt3DRender::QAbstractTexture::Linear );
+  mDepthRenderCaptureColorTexture->setMagnificationFilter( Qt3DRender::QAbstractTexture::Linear );
+
+  // Hook the texture up to our output, and the output up to this object.
+  colorOutput->setTexture( mDepthRenderCaptureColorTexture );
+  depthRenderTarget->addOutput( colorOutput );
+
+  Qt3DRender::QRenderTargetOutput *depthOutput = new Qt3DRender::QRenderTargetOutput( depthRenderTarget );
+
+  depthOutput->setAttachmentPoint( Qt3DRender::QRenderTargetOutput::Depth );
+  mDepthRenderCaptureDepthTexture = new Qt3DRender::QTexture2D( depthOutput );
+  mDepthRenderCaptureDepthTexture->setSize( mSize.width(), mSize.height() );
+  mDepthRenderCaptureDepthTexture->setFormat( Qt3DRender::QAbstractTexture::DepthFormat );
+  mDepthRenderCaptureDepthTexture->setMinificationFilter( Qt3DRender::QAbstractTexture::Linear );
+  mDepthRenderCaptureDepthTexture->setMagnificationFilter( Qt3DRender::QAbstractTexture::Linear );
+  mDepthRenderCaptureDepthTexture->setComparisonFunction( Qt3DRender::QAbstractTexture::CompareLessEqual );
+  mDepthRenderCaptureDepthTexture->setComparisonMode( Qt3DRender::QAbstractTexture::CompareRefToTexture );
+
+  depthOutput->setTexture( mDepthRenderCaptureDepthTexture );
+  depthRenderTarget->addOutput( depthOutput );
+
+  mDepthRenderCaptureTargetSelector->setTarget( depthRenderTarget );
+
+  Qt3DRender::QClearBuffers *clearBuffers = new Qt3DRender::QClearBuffers( mDepthRenderCaptureTargetSelector );
+  clearBuffers->setClearColor( QColor::fromRgbF( 0.0, 0.0, 1.0, 1.0 ) );
+  clearBuffers->setBuffers( Qt3DRender::QClearBuffers::ColorDepthBuffer );
+
+  mDepthRenderCapture = new Qt3DRender::QRenderCapture( mDepthRenderCaptureTargetSelector );
+
   mPostprocessingEntity = new QgsPostprocessingEntity( this, mRootEntity );
   mPostprocessingEntity->addComponent( mPostprocessPassLayer );
 
   // textures preview pass
   Qt3DRender::QFrameGraphNode *previewPass = constructTexturesPreviewPass();
-  previewPass->setParent( mRenderSurfaceSelector );
+  previewPass->setParent( mSecondMainCameraSelector );
 
+  Qt3DRender::QParameter *depthMapIsDepthParam = new Qt3DRender::QParameter( "isDepth", true );
+  Qt3DRender::QParameter *shadowMapIsDepthParam = new Qt3DRender::QParameter( "isDepth", false );
 
-  mDebugDepthMapPreviewQuad = this->addTexturePreviewOverlay( mForwardDepthTexture, QPointF( 0.8f, 0.8f ), QSizeF( 0.2f, 0.2f ) );
-  mDebugShadowMapPreviewQuad = this->addTexturePreviewOverlay( mShadowMapTexture, QPointF( -0.8f, -0.8f ), QSizeF( 0.2f, 0.2f ) );
+  mDebugDepthMapPreviewQuad = this->addTexturePreviewOverlay( mForwardDepthTexture, QPointF( 0.8f, 0.8f ), QSizeF( 0.2f, 0.2f ), QVector<Qt3DRender::QParameter *>{ depthMapIsDepthParam } );
+  mDebugShadowMapPreviewQuad = this->addTexturePreviewOverlay( mShadowMapTexture, QPointF( -0.8f, -0.8f ), QSizeF( 0.2f, 0.2f ), QVector<Qt3DRender::QParameter *>{ shadowMapIsDepthParam } );
   mDebugDepthMapPreviewQuad->setEnabled( false );
   mDebugShadowMapPreviewQuad->setEnabled( false );
+
+  // Custom preview quad, used as a way to render the depth buffer to a color texture
+  Qt3DRender::QParameter *isDepthParam = new Qt3DRender::QParameter( "isDepth", true );
+  mDepthRenderQuad = new QgsPreviewQuad( mForwardDepthTexture, QPointF( 0.0f, 0.0f), QSizeF( 1.0f, 1.0f ), QVector<Qt3DRender::QParameter *>{ isDepthParam } );
+  mDepthRenderQuad->addComponent( mDepthRenderPassLayer );
+  mDepthRenderQuad->setParent( mRootEntity );
+  mPreviewQuads.push_back( mDepthRenderQuad );
 }
 
 QgsPreviewQuad *QgsShadowRenderingFrameGraph::addTexturePreviewOverlay( Qt3DRender::QTexture2D *texture, const QPointF &centerNDC, const QSizeF &size, QVector<Qt3DRender::QParameter *> additionalShaderParameters )
@@ -448,6 +518,8 @@ void QgsShadowRenderingFrameGraph::setSize( QSize s )
   mForwardDepthTexture->setSize( mSize.width(), mSize.height() );
   mRenderCaptureColorTexture->setSize( mSize.width(), mSize.height() );
   mRenderCaptureDepthTexture->setSize( mSize.width(), mSize.height() );
+  mDepthRenderCaptureDepthTexture->setSize( mSize.width(), mSize.height() );
+  mDepthRenderCaptureColorTexture->setSize( mSize.width(), mSize.height() );
   mRenderSurfaceSelector->setExternalRenderTargetSize( mSize );
 }
 
diff --git a/src/3d/qgsshadowrenderingframegraph.h b/src/3d/qgsshadowrenderingframegraph.h
index 2031f9f558..e288170652 100644
--- a/src/3d/qgsshadowrenderingframegraph.h
+++ b/src/3d/qgsshadowrenderingframegraph.h
@@ -90,6 +90,9 @@ class QgsShadowRenderingFrameGraph : public Qt3DCore::QEntity
     //! Returns the render capture object used to take an image of the scene
     Qt3DRender::QRenderCapture *renderCapture() { return mRenderCapture; }
 
+    //! Returns the render capture object used to take an image of the depth buffer of the scene
+    Qt3DRender::QRenderCapture *depthRenderCapture() { return mDepthRenderCapture; }
+
     //! Returns whether frustum culling is enabled
     bool frustumCullingEnabled() const { return mFrustumCullingEnabled; }
     //! Sets whether frustum culling is enabled
@@ -171,8 +174,16 @@ class QgsShadowRenderingFrameGraph : public Qt3DCore::QEntity
     Qt3DRender::QCameraSelector *mLightCameraSelector = nullptr;
 
     Qt3DRender::QRenderTargetSelector *mRenderCaptureTargetSelector = nullptr;
+    Qt3DRender::QRenderTargetSelector *mDepthRenderCaptureTargetSelector = nullptr;
     Qt3DRender::QTexture2D *mRenderCaptureColorTexture = nullptr;
     Qt3DRender::QTexture2D *mRenderCaptureDepthTexture = nullptr;
+    Qt3DRender::QClearBuffers *mPostProcessingClearBuffers = nullptr;
+
+    Qt3DRender::QLayerFilter *mDepthRenderLayerFilter = nullptr;
+    Qt3DRender::QTexture2D *mDepthRenderCaptureDepthTexture = nullptr;
+    Qt3DRender::QCameraSelector *mSecondMainCameraSelector = nullptr;
+    Qt3DRender::QRenderStateSet *DepthRenderStateSet = nullptr;;
+    Qt3DRender::QTexture2D *mDepthRenderCaptureColorTexture = nullptr;
 
     bool mShadowRenderingEnabled = false;
     float mShadowBias = 0.00001f;
@@ -187,12 +198,15 @@ class QgsShadowRenderingFrameGraph : public Qt3DCore::QEntity
     QgsPreviewQuad *mDebugShadowMapPreviewQuad = nullptr;
     QgsPreviewQuad *mDebugDepthMapPreviewQuad = nullptr;
 
+    QgsPreviewQuad *mDepthRenderQuad = nullptr;
+
     Qt3DRender::QLayerFilter *mShadowSceneEntitiesFilter = nullptr;
     Qt3DRender::QRenderStateSet *mShadowRenderStateSet = nullptr;
     Qt3DRender::QCullFace *mShadowCullFace = nullptr;
     Qt3DRender::QDepthTest *mShadowDepthTest = nullptr;
 
     Qt3DRender::QRenderCapture *mRenderCapture = nullptr;
+    Qt3DRender::QRenderCapture *mDepthRenderCapture = nullptr;
 
     QVector3D mLightDirection = QVector3D( 0.0, -1.0f, 0.0f );
 
@@ -202,6 +216,7 @@ class QgsShadowRenderingFrameGraph : public Qt3DCore::QEntity
     Qt3DRender::QLayer *mPreviewLayer = nullptr;
     Qt3DRender::QLayer *mForwardRenderLayer = nullptr;
     Qt3DRender::QLayer *mCastShadowsLayer = nullptr;
+    Qt3DRender::QLayer *mDepthRenderPassLayer = nullptr;
 
     QgsPostprocessingEntity *mPostprocessingEntity = nullptr;
 
diff --git a/src/3d/shaders/pointcloud.vert b/src/3d/shaders/pointcloud.vert
index 3baa35fa96..e92ab314f4 100644
--- a/src/3d/shaders/pointcloud.vert
+++ b/src/3d/shaders/pointcloud.vert
@@ -17,10 +17,15 @@ out vec3 pointColor;
 
 void main(void)
 {
+    float near = projectionMatrix[3][2] / (projectionMatrix[2][2] - 1.0);
+    float far = projectionMatrix[3][2] / (projectionMatrix[2][2] + 1.0);
+
     //if (abs(cls-5) < 0.1)
     //    gl_Position = vec4(0,0,0,0);
     //else
         gl_Position = modelViewProjection * vec4(vertexPosition, 1);
+//        gl_Position.z = (gl_Position.z - near) / (far - near);
+
 
     gl_PointSize = u_pointSize; //5 + vertexPosition.x * 10 + vertexPosition.y * 10;
     //gl_PointSize = viewportMatrix[1][1] * projectionMatrix[1][1] * 1.0 / gl_Position.w;
diff --git a/src/3d/shaders/preview.frag b/src/3d/shaders/preview.frag
index 15e79324db..ad4ae35ba3 100644
--- a/src/3d/shaders/preview.frag
+++ b/src/3d/shaders/preview.frag
@@ -2,19 +2,45 @@
 
 uniform sampler2D previewTexture;
 uniform bool isDepth;
+uniform mat4 projectionMatrix;
+uniform mat4 inverseProjectionMatrix;
+uniform mat4 viewMatrix;
+uniform mat4 inverseViewMatrix;
 
 in vec3 position;
 in vec2 texCoord;
 
 out vec4 fragColor;
 
+// this is supposed to get the world position from the depth buffer
+vec3 WorldPosFromDepth(float depth) {
+    float z = depth * 2.0 - 1.0;
+
+    vec4 clipSpacePosition = vec4(texCoord * 2.0 - 1.0, z, 1.0);
+    vec4 viewSpacePosition = inverseProjectionMatrix * clipSpacePosition;
+
+    // Perspective division
+    viewSpacePosition /= viewSpacePosition.w;
+
+    vec4 worldSpacePosition = inverseViewMatrix * viewSpacePosition;
+
+    return worldSpacePosition.xyz;
+}
+
 void main()
 {
   // Warning:
   // When trying to display a depth texture make sure to linearize the depth value
   // if you are using a perspective projection
   if (isDepth)
-    fragColor = vec4(vec3(texture(previewTexture, texCoord).r), 1.0f);
+  {
+    int depth = int( clamp( texture(previewTexture, texCoord).r, 0.0, 1.0 ) * 256 * 256 * 256 );
+//    [x * y * z]
+
+    fragColor = vec4( depth / 256.0 / 256.0 / 256.0, float( depth / 256 % 256 ) / 256.0, float( depth % 256 ) / 256.0, 1.0f);
+
+//      fragColor = vec4( normalize( WorldPosFromDepth( texture(previewTexture, texCoord).r ) ), 1.0f );
+  }
   else
     fragColor = vec4(texture(previewTexture, texCoord).rgb, 1.0f);
 }
diff --git a/src/app/3d/qgs3dmapcanvas.cpp b/src/app/3d/qgs3dmapcanvas.cpp
index 8b20dd6f17..2f4c581b1e 100644
--- a/src/app/3d/qgs3dmapcanvas.cpp
+++ b/src/app/3d/qgs3dmapcanvas.cpp
@@ -51,6 +51,13 @@ Qgs3DMapCanvas::Qgs3DMapCanvas( QWidget *parent )
     emit savedAsImage( mCaptureFileName );
   } );
 
+  connect( mEngine, &QgsAbstract3DEngine::depthBufferCaptured, [ = ]( const QImage & image )
+  {
+    qDebug() << "Elapsed time: " << mEngine->mTimer.elapsed();
+    mDepthBufferImage = image;
+    cameraController()->setDepthBufferImage( image );
+  } );
+
   mSplitter = new QSplitter( this );
 
   mContainer = QWidget::createWindowContainer( mEngine->window() );
@@ -130,6 +137,7 @@ void Qgs3DMapCanvas::setMap( Qgs3DMapSettings *map )
   connect( cameraController(), &QgsCameraController::cameraMovementSpeedChanged, mMap, &Qgs3DMapSettings::setCameraMovementSpeed );
   connect( cameraController(), &QgsCameraController::cameraMovementSpeedChanged, this, &Qgs3DMapCanvas::cameraNavigationSpeedChanged );
   connect( cameraController(), &QgsCameraController::navigationModeHotKeyPressed, this, &Qgs3DMapCanvas::onNavigationModeHotKeyPressed );
+  connect( cameraController(), &QgsCameraController::requestDepthBufferCapture, this, &Qgs3DMapCanvas::captureDepthBuffer );
 
   emit mapSettingsChanged();
 }
@@ -215,6 +223,21 @@ void Qgs3DMapCanvas::saveAsImage( const QString fileName, const QString fileForm
   }
 }
 
+void Qgs3DMapCanvas::captureDepthBuffer()
+{
+  // Setup a frame action that is used to wait until next frame
+  Qt3DLogic::QFrameAction *screenCaptureFrameAction = new Qt3DLogic::QFrameAction;
+  mScene->addComponent( screenCaptureFrameAction );
+  // Wait to have the render capture enabled in the next frame
+  connect( screenCaptureFrameAction, &Qt3DLogic::QFrameAction::triggered, [ = ]( float )
+  {
+    mEngine->requestDepthBufferCapture();
+    qDebug() << "requestDepthBufferCapture duration: " << mEngine->mTimer.elapsed();
+    mScene->removeComponent( screenCaptureFrameAction );
+    screenCaptureFrameAction->deleteLater();
+  } );
+}
+
 void Qgs3DMapCanvas::setMapTool( Qgs3DMapTool *tool )
 {
   if ( tool == mMapTool )
diff --git a/src/app/3d/qgs3dmapcanvas.h b/src/app/3d/qgs3dmapcanvas.h
index 5d5a3c991b..c33583b3cb 100644
--- a/src/app/3d/qgs3dmapcanvas.h
+++ b/src/app/3d/qgs3dmapcanvas.h
@@ -117,6 +117,8 @@ class Qgs3DMapCanvas : public QWidget
      * \since QGIS 3.18
      */
     void cameraNavigationSpeedChanged( double speed );
+  public slots:
+    void captureDepthBuffer();
 
   private slots:
     void updateTemporalRange( const QgsDateTimeRange &timeRange );
@@ -148,6 +150,8 @@ class Qgs3DMapCanvas : public QWidget
     QgsTemporalController *mTemporalController = nullptr;
 
     QSplitter *mSplitter = nullptr;
+
+    QImage mDepthBufferImage;
 };
 
 #endif // QGS3DMAPCANVAS_H
