/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/geometry/qgsquadrilateral.h                                 *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/





class QgsQuadrilateral
{
%Docstring
Quadrilateral geometry type.
A quadrilateral is a polygon with four edges (or sides) and four vertices or corners.
This class allows the creation of simple quadrilateral (which does not self-intersect).

.. versionadded:: 3.6
%End

%TypeHeaderCode
#include "qgsquadrilateral.h"
%End
  public:
    QgsQuadrilateral();

    QgsQuadrilateral( const QgsPoint &p1, const QgsPoint &p2, const QgsPoint &p3, const QgsPoint &p4 );
%Docstring
Construct a QgsQuadrilateral from three :py:class:`QgsPoint`.

:param p1: first point
:param p2: second point
:param p3: third point
:param p4: fourth point

.. seealso:: :py:func:`setPoints`
%End

    explicit QgsQuadrilateral( const QgsPointXY &p1, const QgsPointXY &p2, const QgsPointXY &p3, const QgsPointXY &p4 );
%Docstring
Construct a QgsQuadrilateral from four :py:class:`QgsPoint`.

:param p1: first point
:param p2: second point
:param p3: third point
:param p4: fourth point

.. seealso:: :py:func:`setPoints`
%End


    enum ConstructionOption
    {
      Distance,
      Projected,
    };

    static QgsQuadrilateral rectangleFrom3Points( const QgsPoint &p1, const QgsPoint &p2, const QgsPoint &p3, ConstructionOption mode );
%Docstring
Construct a QgsQuadrilateral as a Rectangle from 3 points.

:param p1: first point
:param p2: second point
:param p3: third point
:param mode: Construction mode to construct the rectangle from 3 points

.. seealso:: ConstructionOption
%End

    static QgsQuadrilateral rectangleFromExtent( const QgsPoint &p1, const QgsPoint &p2 );
%Docstring
Construct a QgsQuadrilateral as a Rectangle from is extent.
Z is taken from point ``p1``.

:param p1: first point
:param p2: second point
%End


    static QgsQuadrilateral squareFromDiagonal( const QgsPoint &p1, const QgsPoint &p2 );
%Docstring
Construct a QgsQuadrilateral as a Square from a diagonal.
Z is taken from point ``p1``.

:param p1: first point
:param p2: second point
%End

    static QgsQuadrilateral rectangleFromCenterPoint( const QgsPoint &center, const QgsPoint &point );
%Docstring
Construct a QgsQuadrilateral as a Rectangle from center point ``center``
and another point ``point``.
Z is taken from ``center`` point.

:param center: center point
:param point: corner point
%End

    static QgsQuadrilateral fromRectangle( const QgsRectangle &rectangle );
%Docstring
Construct a QgsQuadrilateral as a Rectangle from a :py:class:`QgsRectangle`.

:param rectangle: rectangle
%End


    bool equals( const QgsQuadrilateral &other, double epsilon = 4 * DBL_EPSILON ) const;
%Docstring
Compare two QgsQuadrilateral but allow to specify the maximum difference
allowable between points.

:param other: the QgsQuadrilateral to compare
:param epsilon: the maximum difference allowed / tolerance
%End
    bool operator==( const QgsQuadrilateral &other ) const;
    bool operator!=( const QgsQuadrilateral &other ) const;

    bool isValid() const;
%Docstring
Convenient method to determine if a QgsQuadrilateral is valid.
A QgsQuadrilateral must be simple (not self-intersecting) and
cannot have collinear points.
%End

    enum Point
    {
      Point1,
      Point2,
      Point3,
      Point4,
    };

    bool setPoint( const QgsPoint &newPoint, Point index );
%Docstring
Sets the point ``newPoint`` at the ``index``.
Returns false if the QgsQuadrilateral is not valid.

.. seealso:: Point
%End

    bool setPoints( const QgsPoint &p1, const QgsPoint &p2, const QgsPoint &p3, const QgsPoint &p4 );
%Docstring
Set all points
Returns false if the QgsQuadrilateral is not valid:
- The points do not have the same type
- The quadrilateral would have auto intersections
- The quadrilateral has double points
- The quadrilateral has collinear points

:param p1: first point
:param p2: second point
:param p3: third point
:param p4: fourth point
%End

    QgsPointSequence points() const;
%Docstring
Returns a list including the vertices of the quadrilateral.
%End

    QgsPolygon *toPolygon( bool force2D = false ) const /Factory/;
%Docstring
Returnns as a new polygon. Ownership is transferred to the caller.
%End

    QgsLineString *toLineString( bool force2D = false ) const /Factory/;
%Docstring
Returnns as a new linestring. Ownership is transferred to the caller.
%End

    QString toString( int pointPrecision = 17 ) const;
%Docstring
Returns a string representation of the quadrilateral.
Members will be truncated to the specified precision.
%End

    double area() const;
%Docstring
Returns the area.
Returns 0 if the quadrilateral is empty.
%End

    double perimeter() const;
%Docstring
Returns the perimeter.
Returns 0 if the quadrilateral is empty.
%End
    SIP_PYOBJECT __repr__();
%MethodCode
    QString str = QStringLiteral( "<QgsQuadrilateral: %1>" ).arg( sipCpp->toString() );
    sipRes = PyUnicode_FromString( str.toUtf8().constData() );
%End
};

/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/geometry/qgsquadrilateral.h                                 *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/
