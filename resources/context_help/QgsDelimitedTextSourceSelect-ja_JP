<h3>デリミティッドテキストレイヤ</h3>
デリミティッドテキストファイルを読み込んで表示します
<p>
<a href="#re">概要</a><br/>
<a href="#creating">デリミティッドテキストレイヤの作成</a><br/>
<a href="#csv">デリミタとクォート文字とエスケープ文字はどう機能するか</a><br />
<a href="#regexp">正規表現デリミタはどう機能するか</a><br />
<a href="#wkt">WKTテキストはどう解釈されるか</a><br />
<a href="#attributes">デリミティッドテキストファイルの属性</a><br />
<a href="#example">X, Yポイント座標を持つテキストファイルの例</a><br/>
<a href="#wkt_example">WKTジオメトリを持つテキストファイルの例</a><br/>
<a href="#python">Pythonでデリミティッドテキストレイヤを使うには</a><br/>
</p>

<h4><a name="re">概要</a></h4>
<p>&quot;デリミティッドテキストファイル&quot;とは各レコードが新しい行で始まりコンマ等の区切り文字(デリミタ)でフィールドに分けられたデータです.
このファイルタイプは一般的に表計算ソフト(例えばCSVファイルとして)やデータベースからエクスポートされます.
一般的には最初の行にはフィールドの名前を持ちます.
</p>
<p>
デリミティッドテキストファイルはQGISにレイヤとして読み込むことができます.
レコードはX, Y座標で定義されたポイントとして空間的に表示することができます.
またWell Known Text (WKT)という任意の複雑なポイントやライン，ポリゴンを表すジオメトリの定義を用いて空間的に表示することもできます.
ファイルは属性のみのテーブルとして読み込むこともできます. それはQGISで他のテーブルに結合することができます.
</p>
<p>
ファイルにはジオメトリ定義に加えてテキストや整数、実数フィールドを含むことができます.
デフォルトではQGISはフィールドの空ではない値に基づいてそのタイプを選びます.
全ての値が整数として解釈できる場合は整数型となり、全ての値が実数として解釈できる場合は倍精度数型となります. そうでなければテキスト型になります.
</p>
<p>
QGISはOGR CSVドライバと互換性のある&quot;csvt&quot;ファイルからフィールドのタイプを読むことができます.
これはデータファイルのそばにあるファイルですがファイル名(拡張子)に&quot;t&quot;が追加されます.
このファイルは各フィールドのタイプが列挙されている1行を含まなければなりません.
有効なタイプは&quot;integer&quot;, &quot;real&quot;, &quot;string&quot;, &quot;date&quot;, &quot;time&quot;そして&quot;datetime&quot;です.
date型やtime型, datetime型はQGISで文字列として扱われます.
それぞれのタイプには幅と精度が続くことがあります. 例えば&quot;real(10.4)&quot;.
タイプのリストはデータファイルで使われているデリミタとはかかわりなくコンマで区切られます.
次は有効なフォーマットのファイルの例です:
</p>

<pre>
&quot;integer&quot;,&quot;string&quot;,&quot;string(20)&quot;,&quot;real(20.4)&quot;
</pre>

<h4><a name="creating">デリミティッドテキストレイヤの作成</a></h4>
<p>デリミティッドテキストレイヤを作成するにはデータファイルを選び、形式(どのように各レコードがフィールドに分けられているか)を定義して、ジオメトリがどう表されているか定義します.
下で詳述されるように、これはデリミティッドテキストダイアログで行うことができます.
ダイアログボックスには形式オプションがどう適用されるかを示すファイルの先頭部分のサンプルが表示されます.
</p>
<h5>データファイルの選択</h5>
<p>データファイルを選択するには&quot;参照...&quot;ボタンを使います.
ファイルが選択されたらレイヤ名はファイル名に基づいて自動的に入力されます.
レイヤ名はQGISの凡例でデータを表すのに使われます.
</p>
<p>
デフォルトではファイルのエンコーディングはUTF-8が選ばれていますが、他のエンコーディングを選ぶこともできます.
例えば&quot;System&quot;を選べばオペレーションシステムのデフォルトエンコーディングを使用します.
QGISプロジェクトを異機種間で移動して使う必要がある場合は、明示的なエンコーディングを使用する方が安全です.
</p>
<h5>ファイル形式の指定</h5>
<p>ファイル形式には次の形式があります
<ul>
    <li>CSVファイル形式.  これは表計算ソフトで一般的に使われる形式です.フィールドはコンマ文字で境され、&quot;文字(ダブルクォート)で囲まれます.
    ダブルクォートで囲まれたフィールドではダブルクォートは&quot;&quot;として入力することができます.</li>
    <li>選択された区切り文字.  各レコードは1つかそれ以上のデリミタを用いてフィールドに分けられます.
    クォート文字はデリミタを含むフィールドに使用されます.
    エスケープ文字は次の文字を通常の文字として扱う(デリミタやクォート文字、改行文字をテキストフィールドに含める)ために使用できます.
    デリミタやクォート文字、エスケープ文字の使い方は<a href="#csv">下</a>に詳しく述べられています.
    <li>正規表現. 各行は&quot;正規表現&quot; デリミタを用いてフィールドに分けられます.
    正規表現の使い方は<a href="#regexp">下</a>に詳しく述べられています.
</ul>

<h5>レコードオプションとフィールドオプション</h5>
<p>次のオプションはデータファイルからのレコードとフィールドの選抜に影響します</p>
<ul>
    <li>無視するヘッダー行数: テキストファイルの先頭部分のヘッダ行を無視するために使われます</li>
    <li>最初のレコードはフィールド名を保持している: チェックされている場合、ファイルの(無視された行の後の)最初のレコードはデータレコードではなくフィールド名として解釈されます.</li>
    <li>前後の空白削除: チェックされている場合、各フィールドから先頭と末尾の空白が削除されます(クォート文字で囲まれたフィールドを除く).</li>
    <li>空フィールドを削除: チェックされている場合、(前後の空白削除の後に)空のフィールドは破棄されます.
    これはフィールドへのデータ配置に影響を与え、連続したデリミタを単一のデリミタとして処理することに相当します.
    クォート文字で囲まれたフィールドは決して破棄されません.</li>
    <li>コンマを小数点区切りに指定: チェックされている場合、ポイント(ピリオド)の代わりにコンマが実数の小数区切り文字に使われます.
    例えば<tt>-51,354</tt>は-51.354と等しくなります.
    </li>
</ul>
<h5>ジオメトリ定義</h5>
<p>ジオメトリは次のいずれかとして定義できます.</p>
<ul>
    <li>ポイント座標: 各地物はX, Y座標で定義されるポイントとして表現されます.</li>
    <li>Well known text (WKT)ジオメトリ: 各地物はWell known textとして表現されます. 例えば
    <tt>POINT(1.525622 51.20836)</tt>.  詳細は<a href="#wkt">well known text</a>形式を参照して下さい.
    <li>ジオメトリなし (属性のみのテーブル): レコードは地図には表示されませんが属性テーブルで表示できます.
    QGISの他のレイヤと結合することもできます.</li>
</ul>
<p>ポイント座標の場合は次のオプションが適用されます:</p>
<ul>
    <li>Xフィールド: X座標を含んでいるフィールドを指定します</li>
    <li>Yフィールド: Y座標を含んでいるフィールドを指定します</li>
    <li>度分秒を使用: チェックされている場合、座標は度/分/秒または度/分で表されています.
    QGISは度/分/秒の解釈に非常に寛容です. 正しいDMS座標は3つの数値フィールドとオプションで半球の接頭辞か接尾辞を含みます (N, Eまたは+は正, S, Wまたは-は負).
    その他の数字ではない文字は一般的に破棄されます. 例えば<tt>N41d54'01.54&quot;</tt>は有効な座標です.
    </li>
</ul>
<p>Well known textジオメトリの場合は次のオプションが適用されます:</p>
<ul>
    <li>ジオメトリフィールド: Well known text定義を含んでいるフィールド.</li>
    <li>ジオメトリタイプ: &quot;検出する&quot;, &quot;点&quot;, &quot;ライン&quot;, &quot;ポリゴン&quot;から選択します.
QGISレイヤは一つのジオメトリ地物タイプ(点, ラインまたはポリゴン)を表示することができます.
このオプションはテキストファイルが複数のジオメトリタイプを含んでいる場合にどのジオメトリタイプを表示するか選択します.
他のジオメトリタイプのレコードは破棄されます.
&quot;Detect&quot;が選択された場合、ファイルの最初のジオメトリのタイプが使用されます.
&quot;Point&quot;はPOINTとMULTIPOINTのWKTタイプを含みます.
&quot;Line&quot;はLINESTRINGとMULTILINESTRINGのWKTタイプを含みます.
&quot;Polygon&quot;はPOLYGONとMULTIPOLYGONのWKTタイプを含みます.
</ul>
<h5>レイヤ設定</h5>
<p>レイヤ設定はQGISでレイヤが扱われる方法を管理します. 次のオプションが利用可能です:</p>
<ul>
<li>空間インデックスを利用する. 空間オブジェクトの表示と選択のパフォーマンスを良くするために空間インデックスを作成します.
このオプションはサイズが数メガバイトより大きなファイルに役立つでしょう.</li>
<li>サブセットインデックスを利用する. レコードのサブセットが使われている場合インデックスを作成する
(レイヤプロパティダイアログからサブセット文字列を明示的に設定する場合や、全てのジオメトリが有効ではないファイルの中でジオメトリが有効な地物の暗黙のサブセット).
インデックスはサブセットが定義されている時のみ作成されます.</li>
<li>ファイル監視. このオプションがチェックされている場合、QGISは他のアプリケーションによるファイルの変更を監視し、変更された時にファイルを読み直します.
地図はユーザによってリフレッシュされるまで更新されませんが、インデックスと領域はリロードされます.このオプションはインデックスが利用されていて他のアプリケーションがファイルを変更しそうであればチェックされるべきです.</li>
</ul>

<h4><a name="csv">デリミタとクォート文字とエスケープ文字はどう機能するか</a></h4>
<p>レコードは3つの文字のセットを用いてフィールドに分けられます:
デリミタ, クォート文字, そしてエスケープ文字です. その他の文字はデータとみなされ区切り文字によってフィールドに分けられます.
クォート文字はペアで用いてそのあいだのテキストをデータとして扱われるようにします. エスケープ文字はそれに続く文字をデータとして扱われるようにします.
</p>
<p>
クォート文字とエスケープ文字はデリミタと同じではいけません.
もしそうであればそれらは無視されます.
エスケープ文字はクォート文字と同じでもよいですが、異なるふるまいをします.</p>
<p>デリミタは各フィールドの終わりのマークとして使われます. もし1つより多くのデリミタが定義されている場合はどれか1つの文字がフィールドの終わりのしるしとなります.
クォート文字とエスケープ文字は通常の文字として扱われるようにするためにデリミタを上書きすることができます.</p>
<p>クォート文字はクォート文字で囲まれたフィールドの最初と最後のマークに用いられます.
クォート文字で囲まれたフィールドにはデリミタを含むことができ、テキストファイルの複数行にわたることができます.
フィールドがクォート文字で囲まれている場合、同じクォート文字で始まり、終わらなければいけません.
クォート文字はエスケープされなければフィールドの中には現れません.</p>
<p>クォート文字ではないエスケープ文字はそれに続く文字をデータとして扱われるようにします.
(それは改行文字やデリミタ、クォート文字として扱われないようにするためです)
</p>
<p>クォート文字でもあるエスケープ文字にはより限られた効果があります.
それらはクォート文字の中にだけ適用され、それら自身のみエスケープします.
例えば、もし<tt>'</tt>がクォート文字でありエスケープ文字でもあるときは、
文字列<tt>'Smith''s&nbsp;Creek'</tt>はSmith's&nbsp;Creekの値を表します.
</p>


<h4><a name="regexp">正規表現デリミタはどう機能するか</a></h4>
<p>正規表現は文字パターンを表すために使用されるミニ言語です.
正規表現の構文には多くのバリエーションがあります.
QGISは<a href="http://qt.digia.com">Qt</a>フレームワークの<a href="http://qt-project.org/doc/qt-4.8/qregexp.html">QRegExp</a>クラスによって提供される構文を使用します.</p>
<p>正規表現デリミティッドファイルでは各行はレコードとして扱われます.
行の中でそれぞれの正規表現のマッチはフィールドの終わりとして扱われます.
もし正規表現がキャプチャグループ(例 <tt>(cat|dog)</tt>)を含む場合はそれらはフィールドとして抜き出されます.
これを望まない時はキャプチャしないグループ(例 <tt>(?:cat|dog)</tt>)を使います.
</p>
<p>正規表現が行の始めにアンカーされている場合は異なる扱われ方がされます(パターンが<tt>^</tt>で始まる場合です).
この場合正規表現は各行に対してマッチします.
行がマッチない時は不正なレコードとして破棄されます.
正規表現のそれぞれのキャプチャグループはフィールドとして扱われます.
キャプチャグループがない場合はその正規表現は有効ではありません.
例としては(やや直感的でないが)固定幅のフィールドを持つデータを読み込むのに使うことができます.
例えば正規表現
<pre>
^(.{5})(.{10})(.{20})(.{20})
</pre>
<p>は各行から幅が文字数5, 10, 20, 20の4つのフィールドが抜き出されます.
長さ55文字に満たない行は破棄されます.
</p>


<h4><a name="wkt">WKTテキストはどう解釈されるか</a></h4>
<p>
デリミティッドテキストレイヤは次の<a href="http://en.wikipedia.org/wiki/Well-known_text">well known text</a>タイプを認識します.
<tt>POINT</tt>, <tt>MULTIPOINT</tt>, <tt>LINESTRING</tt>, <tt>MULTILINESTRING</tt>, <tt>POLYGON</tt>, それに<tt>MULTIPOLYGON</tt>です.
Z座標を持つジオメトリ(例 <tt>POINT&nbsp;Z</tt>)や計測値を持つジオメトリ(<tt>POINT&nbsp;M</tt>)，その両方を持つジオメトリ(<tt>POINT&nbsp;ZM</tt>)を受け入れます.
</p>
<p>
ジオメトリが空間参照システムIDの後にあるPostGIS EWKT(例 <tt>SRID=4326;POINT(175.3&nbsp;41.2)</tt>)や
ジオメトリが整数の空間参照IDの後にあるInformixで使われるWKT(例 <tt>1 POINT(175.3&nbsp;41.2)</tt>)を扱うこともできます
どちらの場合もSRIDは無視されます.
</p>



<h4><a name="attributes">デリミティッドテキストファイルの属性</a></h4>
<p>デリミティッドテキストファイルの各レコードはレコードの属性を表すフィールドに分けられます.
通常属性名はファイルの最初のデータレコードから取得されます.
しかし属性名が含まれていない場合は<tt>field_1</tt>, <tt>field_2</tt>というように名付けられます.
レコードがヘッダレコードで定義されたフィールドより多くのフィールドを有する場合には、それらは<tt>field_#</tt>と名付けられます. ここで#はフィールド番号です
(レコードの終わりの空のフィールドは無視されることに注意して下さい).
テキストファイルのフィールド名が番号である場合や<tt>field_#</tt>といった名前である場合、重複した名前である場合にはQGISは名前を上書きします.
</p>
<p>
データファイル内の明示的な属性に加えてQGISは各レコードにユニークな地物IDを割り当てます.
それはソースファイルにおけるレコードが始まる行の行番号です.
</p>
<p>
各属性は文字列(テキスト), 整数または実数のうちの1つのデータ型を持ちます.
データ型はフィールドの内容から推測されます.
すべての空ではない値が有効な整数の場合は整数型となり、それが実数であれば実数型となります.
そうでなければ文字列になります.
これはフィールドの内容に基づくことに注意して下さい.フィールドをクォート文字で囲んだとしても解釈の方法は変更されません.
</p>


<h4><a name="example">X, Yポイント座標を持つテキストファイルの例</a></h4> 
<pre>
X;Y;ELEV
-300120;7689960;13
-654360;7562040;52
1640;7512840;3
</pre>
<p>このファイルは:</p>
<ul>
<li> <b>;</b>をデリミタに用いています. どんな文字でもフィールドを区切るのに用いることができます.</li>
<li>最初の行はヘッダ行です. フィールド名としてX, Y, ELEVを含みます.</li>
<li>x座標はXフィールドに含まれます.</li>
<li>y座標はYフィールドに含まれます.</li>
</ul>
<h4><a name="wkt_example">WKTジオメトリを持つテキストファイルの例</a></h4>
<pre>
id|wkt
1|POINT(172.0702250 -43.6031036)
2|POINT(172.0702250 -43.6031036)
3|POINT(172.1543206 -43.5731302)
4|POINT(171.9282585 -43.5493308)
5|POINT(171.8827359 -43.5875983)
</pre>
<p>このファイルは:</p>
<ul>
  <li>ヘッダ行に定義された2つのフィールドid, wktを持ちます.
  <li><b>|</b>をデリミタとして用いています.</li>
  <li>各ポイントをWKT表記を用いて指定しています.
</ul>

<h4><a name="python">Pythonでデリミティッドテキストレイヤを使うには</a></h4>
<p>他のベクタレイヤと同様の方法でデリミティッドテキストデータソースをPythonから作成することができます.
サンプル:
</p>
<pre>
from PyQt4.QtCore import QUrl, QString
from qgis.core import QgsVectorLayer, QgsMapLayerRegistry

# Define the data source
filename="test.csv"
uri=QUrl.fromLocalFile(filename)
uri.addQueryItem("type","csv")
uri.addQueryItem("delimiter","|")
uri.addQueryItem("wktField","wkt")
# ... other delimited text parameters
layer=QgsVectorLayer(QString(uri.toEncoded()),"Test CSV layer","delimitedtext")
# Add the layer to the map
if layer.isValid():
    QgsMapLayerRegistry.instance().addMapLayer( layer )
</pre>
<p>これは上の二番目のサンプルファイルをロードするのに使うことができます.</p>
<p>デリミティッドテキストレイヤの構成はクエリ要素をURIに追加することで定義できます.
次のオプションを追加することができます
</p>
<ul>
    <li><tt>encoding=..</tt> ファイルエンコーディングを定義します.  デフォルトは&quot;UTF-8&quot;</li>
    <li><tt>type=(csv|regexp|whitespace)</tt> デリミタのタイプを定義します. 有効な値はcsv, regexp, whitespace (regexpの特別な場合).
       デフォルトはcsv.</li>
       <li><tt>delimiter=...</tt> csv形式ファイルやregexp(正規表現)形式ファイルで用いられるデリミタを定義します.
       CSVファイルではデフォルトは,(コンマ). regexpファイルにはデフォルトはありません.</li>
       <li><tt>quote=..</tt> (csvファイル) フィールドを囲むクォート文字を定義します. デフォルトは&quot;</li>
       <li><tt>escape=..</tt> (csvファイル) これに続く文字を特殊な意味をエスケープするのに用いる文字を定義します. デフォルトは&quot;</li>
       <li><tt>skipLines=#</tt> ファイルの先頭から破棄する行数を定義します. デフォルトは0.</li>
       <li><tt>useHeader=(yes|no)</tt> 最初のデータレコードがフィールド名を含んでいるかどうか定義します.デフォルトはyes.</li>
       <li><tt>trimFields=(yes|no)</tt> クォート文字で囲まれていないフィールドから先頭と末尾の空白を削除するかどうか定義します. デフォルトはno.</li>
       <li><tt>maxFields=#</tt> ファイルから読み込まれるフィールドの最大数を定義します.
       はみ出したフィールドは破棄されます. デフォルトは0で全てのフィールドが読み込まれます
       (このオプションはデリミティッドテキストダイアログボックスにはありません).</li>
       <li><tt>skipEmptyFields=(yes|no)</tt> クォート文字で囲まれていない(trimFieldsが適用された後で)空のフィールドが破棄されるかどうか定義します. デフォルトはno.</li>
       <li><tt>decimalPoint=.</tt> 数値フィールドで小数点として使われる代わりの文字を指定します. デフォルトはポイント(ピリオド)です.</li>
       <li><tt>wktField=fieldname</tt> well known textジオメトリ定義を含むフィールドの名前かインデックス(1から始まる)を指定します.</li>
       <li><tt>xField=fieldname</tt> X座標を含むフィールドの名前かインデックス(1から始まる)を指定します(wktFieldが定義されていない場合にのみ適用されます).</li>
       <li><tt>yField=fieldname</tt> Y座標を含むフィールドの名前かインデックス(1から始まる)を指定します(wktFieldが定義されていない場合にのみ適用されます).</li>
       <li><tt>geomType=(auto|point|line|polygon|none)</tt> wktフィールドのジオメトリのタイプを指定します. noneを指定すると属性のみのテーブルとして読み込まれます. デフォルトはauto.</li>
       <li><tt>subset=expression</tt> 使用されるレコードのサブセットを特定するのに用いる式を指定します.</li>
       <li><tt>crs=...</tt> ベクタレイヤで使用する座標システムをQgsCoordinateReferenceSystem.createFromStringに受け入れられる形式(例えば &quot;EPSG:4167&quot;)で指定する.
       これが指定されない場合はレイヤが読み込まれる時にユーザから情報の入力を求めるダイアログが開きます(QGISのCRS設定による).</li>
       <li><tt>subsetIndex=(yes|no)</tt> 初期ファイルスキャンの間にプロバイダがサブセットを定義するインデックスを構築するかどうか指定する.
       インデックスは明示的に定義されたサブセットとジオメトリ定義が有効な地物の暗黙のサブセットの両方に適用されます.
       デフォルトではサブセットインデックスが適用可能な場合にはそれが構築されます.</li>
       <li><tt>spatialIndex=(yes|no)</tt> 初期ファイルスキャンの間にプロバイダが空間インデックスを構築するかどうか指定する.
       デフォルトでは空間インデックスは構築されません.</li>
       <li><tt>watchFile=(yes|no)</tt> 他のアプリケーションによるファイルの変更を監視するためにプロバイダがファイルシステムウォッチャーを使用するかどうか指定する.</li>
       <li><tt>quiet=(yes|no)</tt> レイヤ読み込み中のエラーをダイアログボックスで表示するかどうか指定します(どちらにせよQGISログには書かれます). デフォルトはnoです.このオプションはGUIからは利用できません.</li>
</ul>
